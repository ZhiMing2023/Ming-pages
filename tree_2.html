<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ğŸ„ æ˜Ÿæ˜Ÿåœ£è¯æ ‘ Â· æ‰‹åŠ¿äº’åŠ¨</title>
  <style>
    :root{--bg:#060a18;--fg:rgba(255,255,255,.92);--muted:rgba(255,255,255,.65)}
    *{box-sizing:border-box}
    body{
      margin:0;min-height:100vh;display:grid;place-items:center;
      background:
        radial-gradient(1100px 700px at 20% 10%, rgba(124,58,237,.22), transparent 55%),
        radial-gradient(900px 600px at 75% 35%, rgba(34,197,94,.14), transparent 55%),
        linear-gradient(180deg, #050714, var(--bg));
      color:var(--fg);
      font-family: system-ui,-apple-system,"PingFang SC","Microsoft YaHei",Arial;
      overflow:hidden;
    }
    .wrap{
      width:min(980px, 96vw);
      padding:16px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      border-radius:18px;
      box-shadow:0 18px 60px rgba(0,0,0,.45);
    }
    h1{margin:0 0 6px 0;font-size:18px}
    .sub{font-size:12px;color:var(--muted);line-height:1.6;margin-bottom:10px}
    .grid{display:grid;grid-template-columns: 1fr;gap:10px}
    canvas{
      width:100%;
      height:auto;
      aspect-ratio: 16/10;
      border-radius:16px;
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.12);
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    button{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.10);
      color:var(--fg);
      border-radius:14px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:650;
    }
    button:hover{transform:translateY(-1px)}
    button:disabled{opacity:.6;cursor:not-allowed;transform:none}
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      padding:6px 10px;border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      font-size:12px;color:var(--muted);
      white-space:nowrap;
    }
    .ok{color:rgba(34,197,94,.95)}
    .warn{color:rgba(250,204,21,.95)}
    .bad{color:rgba(239,68,68,.95)}
    video{display:none}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ğŸ„ æ˜Ÿæ˜Ÿå¡«å……åœ£è¯æ ‘ Â· æ‘„åƒå¤´æ‰‹åŠ¿äº’åŠ¨</h1>
    <div class="sub">
      å…è®¸æ‘„åƒå¤´åï¼š<b>é£ŸæŒ‡æŒ‡å°–</b>ç§»åŠ¨ â†’ æ˜Ÿæ˜Ÿè·Ÿéšï¼›<b>æ‹‡æŒ‡+é£ŸæŒ‡æåˆ</b> â†’ æ˜Ÿæ˜Ÿèšæ‹¢/æ•£å¼€ã€‚<br/>
      å·²åŠ å…¥â€œæ£€æµ‹çŠ¶æ€â€ï¼Œæ–¹ä¾¿åˆ¤æ–­æ˜¯å¦çœŸçš„åœ¨å–‚å¸§ã€‚
    </div>

    <div class="grid">
      <canvas id="view" width="960" height="600"></canvas>

      <div class="row">
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <button id="start">å¼€å¯æ‘„åƒå¤´</button>
          <button id="toggleCam">æ˜¾ç¤º/éšè—æ‘„åƒå¤´èƒŒæ™¯</button>
          <button id="reset">å›æ­£</button>
        </div>

        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <span class="pill">çŠ¶æ€ï¼š<b id="status" class="warn">æœªå¯åŠ¨</b></span>
          <span class="pill">è§†é¢‘å¸§ï¼š<b id="frame" class="warn">0</b></span>
          <span class="pill">ç»“æœï¼š<b id="lastRes" class="warn">â€”</b></span>
          <span class="pill">æ‰‹ï¼š<b id="hand">æœªæ£€æµ‹</b></span>
          <span class="pill">Pinchï¼š<b id="pinch">â€”</b></span>
        </div>
      </div>

      <div class="row" style="justify-content:flex-end">
        <span class="pill">æ˜Ÿæ˜Ÿæ•°ï¼š<b id="n">0</b></span>
      </div>
    </div>

    <video id="video" playsinline></video>
  </div>

  <!-- MediaPipe Hands (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

<script>
(() => {
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');
  const video = document.getElementById('video');

  const startBtn = document.getElementById('start');
  const toggleCamBtn = document.getElementById('toggleCam');
  const resetBtn = document.getElementById('reset');

  const pinchEl = document.getElementById('pinch');
  const handEl = document.getElementById('hand');
  const nEl = document.getElementById('n');

  const statusEl = document.getElementById('status');
  const frameEl = document.getElementById('frame');
  const lastResEl = document.getElementById('lastRes');

  let showCamera = false;
  toggleCamBtn.onclick = () => showCamera = !showCamera;

  function setStatus(text, level="warn"){
    statusEl.textContent = text;
    statusEl.className = level;
  }
  function setLastRes(text, level="warn"){
    lastResEl.textContent = text;
    lastResEl.className = level;
  }

  // ===== Tree mask parameters =====
  const TREE = { cx: 0.52, top: 0.12, bottom: 0.86, halfWidthAtBottom: 0.26, trunkW: 0.06, trunkH: 0.12 };

  // ===== Stars =====
  const STAR_COUNT = 1100;
  const stars = [];
  let basePoints = [];

  function rand(min, max){ return min + Math.random()*(max-min); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function insideTree(u, v){
    const {cx, top, bottom, halfWidthAtBottom} = TREE;
    if (v < top || v > bottom) return false;

    const t = (v - top) / (bottom - top);
    const halfW = halfWidthAtBottom * t;
    const left = cx - halfW;
    const right = cx + halfW;
    const inTri = (u >= left && u <= right);

    const trunkTop = bottom;
    const trunkBottom = bottom + TREE.trunkH;
    const trunkLeft = cx - TREE.trunkW/2;
    const trunkRight = cx + TREE.trunkW/2;
    const inTrunk = (v >= trunkTop && v <= trunkBottom && u >= trunkLeft && u <= trunkRight);

    return inTri || inTrunk;
  }

  function sampleTreePoints(count){
    const pts = [];
    let guard = 0;
    while (pts.length < count && guard < count*80){
      guard++;
      const u = Math.random();
      const v = Math.random();
      if (insideTree(u,v)) pts.push({u, v});
    }
    return pts;
  }

  function drawStar(x, y, r, rot){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    ctx.beginPath();
    const spikes = 5;
    const outer = r;
    const inner = r * 0.45;
    let ang = -Math.PI/2;
    const step = Math.PI / spikes;
    ctx.moveTo(Math.cos(ang)*outer, Math.sin(ang)*outer);
    for(let i=0;i<spikes;i++){
      ctx.lineTo(Math.cos(ang)*outer, Math.sin(ang)*outer);
      ang += step;
      ctx.lineTo(Math.cos(ang)*inner, Math.sin(ang)*inner);
      ang += step;
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function initStars(){
    basePoints = sampleTreePoints(STAR_COUNT);
    stars.length = 0;
    for (let i=0;i<STAR_COUNT;i++){
      const p = basePoints[i];
      stars.push({
        u: p.u, v: p.v,
        x: p.u, y: p.v, vx: 0, vy: 0,
        r: rand(1.2, 2.8),
        rot: rand(0, Math.PI*2),
        tw: rand(0.2, 1.0),
        hue: rand(40, 60)
      });
    }
    nEl.textContent = String(STAR_COUNT);
  }

  // ===== Hand control =====
  let handX = 0.52, handY = 0.45;
  let haveHand = false;
  let pinchStrength = 0.0;

  function resetControl(){
    handX = 0.52; handY = 0.45;
    pinchStrength = 0.0;
  }
  resetBtn.onclick = resetControl;

  function step(dt){
    const attract = 18 + pinchStrength * 55;
    const returnK = 26 * (1 - pinchStrength);
    const damp = 0.86;

    for (let i=0;i<stars.length;i++){
      const s = stars[i];
      const tx = s.u*(1 - pinchStrength) + handX*pinchStrength;
      const ty = s.v*(1 - pinchStrength) + handY*pinchStrength;

      const dx = tx - s.x;
      const dy = ty - s.y;

      const rx = (s.u - s.x) * returnK;
      const ry = (s.v - s.y) * returnK;

      s.vx = (s.vx + dx*attract + rx) * damp;
      s.vy = (s.vy + dy*attract + ry) * damp;

      const jig = (0.0018 + 0.0025*(1-pinchStrength));
      s.vx += (Math.sin((i*0.7 + performance.now()*0.003)))*jig;
      s.vy += (Math.cos((i*0.9 + performance.now()*0.0027)))*jig;

      s.x += s.vx * dt;
      s.y += s.vy * dt;

      s.x = clamp(s.x, 0.02, 0.98);
      s.y = clamp(s.y, 0.02, 0.98);

      s.rot += (0.6 + pinchStrength*1.2) * dt * 0.03;
    }
  }

  function draw(){
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    if (showCamera && video.readyState >= 2){
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.translate(w,0);
      ctx.scale(-1,1);
      ctx.drawImage(video, 0,0,w,h);
      ctx.restore();
    }

    ctx.save();
    const g = ctx.createRadialGradient(w*0.2, h*0.15, 10, w*0.2, h*0.15, w*0.9);
    g.addColorStop(0, "rgba(124,58,237,0.18)");
    g.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    drawTreeSilhouette(w,h);

    for (const s of stars){
      const inTreeNow = insideTree(s.x, s.y) || pinchStrength > 0.35;
      if (!inTreeNow) continue;

      const x = s.x * w;
      const y = s.y * h;
      const tw = 0.65 + 0.35*Math.sin(performance.now()*0.006 + s.tw*10);
      ctx.fillStyle = `hsla(${s.hue} 95% 65% / ${0.55 + 0.35*tw})`;
      drawStar(x, y, s.r * (0.85 + 0.45*tw), s.rot);
    }

    drawTopStar(w,h);

    if (haveHand){
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(34,197,94,0.9)";
      ctx.beginPath();
      ctx.arc(handX*w, handY*h, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  function drawTreeSilhouette(w,h){
    const {cx, top, bottom, halfWidthAtBottom} = TREE;
    ctx.save();
    ctx.fillStyle = "rgba(34,197,94,0.10)";
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo((cx)*w, top*h);
    ctx.lineTo((cx - halfWidthAtBottom)*w, bottom*h);
    ctx.lineTo((cx + halfWidthAtBottom)*w, bottom*h);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "rgba(161,98,7,0.18)";
    const trunkX = (cx - TREE.trunkW/2)*w;
    const trunkY = bottom*h;
    ctx.fillRect(trunkX, trunkY, TREE.trunkW*w, TREE.trunkH*h);

    ctx.fillStyle = "rgba(255,255,255,0.06)";
    ctx.beginPath();
    ctx.ellipse(w*0.52, h*0.89, w*0.42, h*0.10, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawTopStar(w,h){
    const x = TREE.cx*w;
    const y = (TREE.top*h) - 18;
    ctx.save();
    ctx.fillStyle = "rgba(250,204,21,0.95)";
    drawStar(x, y, 14, performance.now()*0.0012);
    ctx.fillStyle = "rgba(250,204,21,0.18)";
    ctx.beginPath();
    ctx.arc(x,y, 34, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // ===== Main loop =====
  let lastT = performance.now();
  function loop(t){
    const dt = Math.min(0.033, (t-lastT)/1000);
    lastT = t;
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // ===== Hands detection (manual feed) =====
  let hands = null;
  let detecting = false;
  let videoFrames = 0;
  let lastResultsAt = 0;

  function dist(a,b){
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function setupHands(){
    hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    // âœ… æŒ‰å»ºè®®ï¼šé™ä½é˜ˆå€¼æ›´å®¹æ˜“æ£€å‡º
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.35,
      minTrackingConfidence: 0.35
    });

    hands.onResults((res) => {
      lastResultsAt = performance.now();
      setLastRes("æ”¶åˆ°", "ok");

      if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0){
        haveHand = false;
        handEl.textContent = "æœªæ£€æµ‹";
        pinchEl.textContent = "â€”";
        return;
      }

      haveHand = true;
      handEl.textContent = "å·²æ£€æµ‹";

      const lm = res.multiHandLandmarks[0];
      const indexTip = lm[8];
      const thumbTip = lm[4];

      const hx = 1 - indexTip.x; // é•œåƒæ›´ç¬¦åˆç›´è§‰
      const hy = indexTip.y;

      handX = handX*0.75 + hx*0.25;
      handY = handY*0.75 + hy*0.25;

      const d = dist(indexTip, thumbTip);
      const p = 1 - clamp((d - 0.03) / 0.18, 0, 1);
      pinchStrength = pinchStrength*0.7 + p*0.3;

      pinchEl.textContent = pinchStrength.toFixed(2);
    });
  }

  async function startCamera(){
    setStatus("ç”³è¯·æ‘„åƒå¤´æƒé™â€¦", "warn");

    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: "user",
        width: { ideal: 960 },
        height: { ideal: 600 }
      },
      audio: false
    });

    video.srcObject = stream;

    await video.play(); // ç¡®ä¿çœŸæ­£å¼€å§‹å‡ºå¸§
    setStatus("æ‘„åƒå¤´å·²å¼€å¯ï¼Œç­‰å¾…è§†é¢‘å¸§â€¦", "warn");
  }

  // æ‰‹åŠ¨å–‚å¸§ï¼šæ¯éš”ä¸€å°ä¼šå„¿æŠŠ video é€è¿› hands.send
  async function feedLoop(){
    if (!detecting) return;

    // video.readyState >= 2 è¡¨ç¤ºæœ‰å½“å‰å¸§å¯ç”¨
    if (video.readyState >= 2){
      videoFrames++;
      frameEl.textContent = String(videoFrames);

      if (videoFrames === 1){
        setStatus("å·²æ”¶åˆ°è§†é¢‘å¸§ï¼Œå¼€å§‹æ£€æµ‹â€¦", "ok");
      }

      // é¿å…å¹¶å‘ sendï¼šç®€å•çš„èŠ‚æµ
      try{
        await hands.send({ image: video });
      }catch(e){
        // å¦‚æœ send å¤±è´¥ï¼Œç»™å‡ºæ˜ç¡®çŠ¶æ€
        setStatus("æ£€æµ‹è°ƒç”¨å¤±è´¥ï¼ˆå¯èƒ½è„šæœ¬æœªåŠ è½½/ç½‘ç»œæ‹¦æˆªï¼‰", "bad");
        console.error(e);
      }
    }

    // çŠ¶æ€ï¼šå¦‚æœå¾ˆä¹…æ²¡æ”¶åˆ° resultsï¼Œæç¤ºâ€œæ­£åœ¨æ£€æµ‹ä¸­/æš‚æ— ç»“æœâ€
    const now = performance.now();
    if (videoFrames > 0){
      if (now - lastResultsAt > 1200){
        setLastRes("æ£€æµ‹ä¸­â€¦", "warn");
      }
    }

    // æ§åˆ¶é¢‘ç‡ï¼š20~30fps æ£€æµ‹è¶³å¤Ÿ
    setTimeout(feedLoop, 50);
  }

  startBtn.onclick = async () => {
    try{
      startBtn.disabled = true;
      startBtn.textContent = "å¯åŠ¨ä¸­â€¦";

      // 1) æ‘„åƒå¤´
      await startCamera();

      // 2) hands
      setupHands();

      // 3) å¼€å§‹æ£€æµ‹å¾ªç¯
      detecting = true;
      setStatus("è¿è¡Œä¸­ï¼ˆæŠŠæ‰‹æŒæ”¾åˆ°é•œå¤´å‰è¯•è¯•ï¼‰", "ok");
      feedLoop();

      startBtn.textContent = "æ‘„åƒå¤´å·²å¼€å¯ âœ…";
    }catch(e){
      console.error(e);
      setStatus("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼ˆæ£€æŸ¥ HTTPS/æƒé™/æµè§ˆå™¨ï¼‰", "bad");
      startBtn.disabled = false;
      startBtn.textContent = "å¼€å¯æ‘„åƒå¤´";
      alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼šè¯·ç¡®è®¤åœ¨ HTTPS é¡µé¢æ‰“å¼€ï¼Œå¹¶å…è®¸æ‘„åƒå¤´æƒé™ï¼›iPhone å»ºè®® Safariï¼Œåˆ«ç”¨å¾®ä¿¡å†…ç½®æµè§ˆå™¨ã€‚");
    }
  };

  // ===== Init =====
  initStars();
  resetControl();
  requestAnimationFrame(loop);

  // é¢å¤–æç¤ºï¼šå¦‚æœæµè§ˆå™¨ä¸æ”¯æŒ getUserMedia
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    setStatus("æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ API", "bad");
  }
})();
</script>
</body>
</html>
