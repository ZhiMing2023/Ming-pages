<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ğŸ„ æ˜Ÿæ˜Ÿåœ£è¯æ ‘ Â· æ‰‹åŠ¿äº’åŠ¨</title>
  <style>
    :root{--bg:#060a18;--fg:rgba(255,255,255,.92);--muted:rgba(255,255,255,.65)}
    *{box-sizing:border-box}
    body{
      margin:0;min-height:100vh;display:grid;place-items:center;
      background:
        radial-gradient(1100px 700px at 20% 10%, rgba(124,58,237,.22), transparent 55%),
        radial-gradient(900px 600px at 75% 35%, rgba(34,197,94,.14), transparent 55%),
        linear-gradient(180deg, #050714, var(--bg));
      color:var(--fg);
      font-family: system-ui,-apple-system,"PingFang SC","Microsoft YaHei",Arial;
      overflow:hidden;
    }
    .wrap{
      width:min(980px, 96vw);
      padding:16px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      border-radius:18px;
      box-shadow:0 18px 60px rgba(0,0,0,.45);
    }
    h1{margin:0 0 6px 0;font-size:18px}
    .sub{font-size:12px;color:var(--muted);line-height:1.6;margin-bottom:10px}
    .grid{display:grid;grid-template-columns: 1fr;gap:10px}
    canvas{
      width:100%;
      height:auto;
      aspect-ratio: 16/10;
      border-radius:16px;
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.12);
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    button{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.10);
      color:var(--fg);
      border-radius:14px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:650;
    }
    button:hover{transform:translateY(-1px)}
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      padding:6px 10px;border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      font-size:12px;color:var(--muted);
    }
    video{display:none}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ğŸ„ æ˜Ÿæ˜Ÿå¡«å……åœ£è¯æ ‘ Â· æ‘„åƒå¤´æ‰‹åŠ¿äº’åŠ¨</h1>
    <div class="sub">
      å…è®¸æ‘„åƒå¤´åï¼š<b>é£ŸæŒ‡æŒ‡å°–</b>ç§»åŠ¨ â†’ æ˜Ÿæ˜Ÿè·Ÿéšï¼›<b>æ‹‡æŒ‡+é£ŸæŒ‡æåˆ</b> â†’ æ˜Ÿæ˜Ÿèšæ‹¢/æ•£å¼€ã€‚<br/>
      ï¼ˆéœ€è¦ HTTPS æ‰æ›´ç¨³å®šï¼šGitHub Pages æœ€åˆé€‚ï¼‰
    </div>

    <div class="grid">
      <canvas id="view" width="960" height="600"></canvas>
      <div class="row">
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <button id="start">å¼€å¯æ‘„åƒå¤´</button>
          <button id="toggleCam">æ˜¾ç¤º/éšè—æ‘„åƒå¤´èƒŒæ™¯</button>
          <button id="reset">å›æ­£</button>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <span class="pill">Pinchï¼š<b id="pinch">â€”</b></span>
          <span class="pill">æ‰‹ï¼š<b id="hand">æœªæ£€æµ‹</b></span>
          <span class="pill">æ˜Ÿæ˜Ÿæ•°ï¼š<b id="n">0</b></span>
        </div>
      </div>
    </div>

    <video id="video" playsinline></video>
  </div>

  <!-- MediaPipe Hands (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
(() => {
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');
  const video = document.getElementById('video');

  const startBtn = document.getElementById('start');
  const toggleCamBtn = document.getElementById('toggleCam');
  const resetBtn = document.getElementById('reset');

  const pinchEl = document.getElementById('pinch');   // æˆ‘å€Ÿç”¨è¿™ä¸ªä½ç½®æ˜¾ç¤ºæ‰‹åŠ¿çŠ¶æ€
  const handEl  = document.getElementById('hand');
  const nEl     = document.getElementById('n');

  const statusEl = document.getElementById('status');
  const frameEl  = document.getElementById('frame');
  const lastResEl= document.getElementById('lastRes');

  let showCamera = false;
  toggleCamBtn.onclick = () => showCamera = !showCamera;

  function setStatus(text, level="warn"){
    statusEl.textContent = text;
    statusEl.className = level;
  }
  function setLastRes(text, level="warn"){
    lastResEl.textContent = text;
    lastResEl.className = level;
  }

  // ===== Tree shape field (normalized) =====
  const TREE = { cx: 0.52, top: 0.12, bottom: 0.86, halfWidthAtBottom: 0.26 };
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }

  function insideTree(u,v){
    const {cx, top, bottom, halfWidthAtBottom} = TREE;
    if (v < top || v > bottom) return false;
    const t = (v - top) / (bottom - top);
    const halfW = halfWidthAtBottom * t;
    return (u >= cx - halfW && u <= cx + halfW);
  }

  // ç”¨â€œå¸å¼•ç‚¹äº‘â€ä½œä¸ºæ ‘çš„â€œä½“ç§¯â€æ¥æºï¼ˆä¸ç¡¬è´´è¾¹ï¼‰
  const ANCHOR_COUNT = 900;
  const anchors = [];
  (function initAnchors(){
    let guard = 0;
    while (anchors.length < ANCHOR_COUNT && guard < ANCHOR_COUNT*120){
      guard++;
      const u = Math.random();
      const v = Math.random();
      if (insideTree(u,v)) anchors.push({u,v});
    }
  })();

  // ===== Boids particles =====
  // æƒ³æ›´åƒä½ å›¾é‡Œé‚£ç§â€œå½©è‰²ç¯ç â€å°±æŠŠæ•°é‡è°ƒå¤§ï¼Œæ‰‹æœºå¡å°±è°ƒå°
  const N = 1400;
  const boids = [];
  function hsvToRgba(h,s,v,a){
    // h:0..360, s/v:0..1
    const c = v*s;
    const x = c*(1-Math.abs(((h/60)%2)-1));
    const m = v-c;
    let r=0,g=0,b=0;
    if (h<60){r=c;g=x;}
    else if (h<120){r=x;g=c;}
    else if (h<180){g=c;b=x;}
    else if (h<240){g=x;b=c;}
    else if (h<300){r=x;b=c;}
    else {r=c;b=x;}
    r=(r+m)*255; g=(g+m)*255; b=(b+m)*255;
    return `rgba(${r|0},${g|0},${b|0},${a})`;
  }

  for (let i=0;i<N;i++){
    const a = anchors[i % anchors.length];
    boids.push({
      x: a.u + rand(-0.02,0.02),
      y: a.v + rand(-0.02,0.02),
      vx: rand(-0.03,0.03),
      vy: rand(-0.03,0.03),
      hue: rand(0,360),       // å½©è‰²
      baseR: rand(1.2, 3.2),  // ç¯ç å¤§å°
      tw: rand(0.3, 1.2),     // é—ªçƒç›¸ä½
      aIdx: i % anchors.length // ç»‘å®šä¸€ä¸ª anchorï¼ˆå›æ ‘é‡Œæ—¶æ›´è‡ªç„¶ï¼‰
    });
  }
  nEl.textContent = String(N);

  // ===== Hand control & gesture =====
  let haveHand = false;
  let handX = 0.52, handY = 0.45;      // é£ŸæŒ‡æŒ‡å°–(é•œåƒå)
  let modeTarget = 0;                  // 0=å›æ ‘é‡Œ(æ•£å¼€) 1=èšæ‹¢åˆ°æ‰‹
  let mode = 0;                        // å¹³æ»‘åçš„æ¨¡å¼
  let videoFrames = 0;
  let lastResultsAt = 0;

  function dist(p,q){
    const dx=p.x-q.x, dy=p.y-q.y;
    return Math.hypot(dx,dy);
  }

  function lerp(a,b,t){ return a + (b-a)*t; }

  // æ‰‹åŠ¿åˆ¤å®šï¼šäº”æŒ‡å¼ å¼€ vs æ¡æ‹³ï¼ˆæ›´ç¨³ä¸€äº›ï¼‰
  // è§„åˆ™ï¼šå¯¹æ¯æ ¹æ‰‹æŒ‡ï¼ˆé™¤æ‹‡æŒ‡ä¹Ÿç®—ï¼‰æ¯”è¾ƒ tip åˆ° wrist çš„è·ç¦» æ˜¯å¦æ˜æ˜¾å¤§äº pip åˆ° wrist
  function fingerExtended(lm, tip, pip){
    const w = lm[0];
    return dist(lm[tip], w) > dist(lm[pip], w) + 0.02;
  }
  function gestureFromLandmarks(lm){
    const exIndex  = fingerExtended(lm, 8, 6);
    const exMiddle = fingerExtended(lm,12,10);
    const exRing   = fingerExtended(lm,16,14);
    const exPinky  = fingerExtended(lm,20,18);
    // æ‹‡æŒ‡ç¨å¾®ç‰¹æ®Šä¸€ç‚¹ï¼štip æ¯” ip æ›´è¿œ
    const exThumb  = dist(lm[4], lm[0]) > dist(lm[3], lm[0]) + 0.015;

    const count = [exThumb,exIndex,exMiddle,exRing,exPinky].filter(Boolean).length;

    // palm center
    const pc = {x:(lm[0].x+lm[5].x+lm[9].x+lm[13].x+lm[17].x)/5, y:(lm[0].y+lm[5].y+lm[9].y+lm[13].y+lm[17].y)/5};
    const closeScore =
      (dist(lm[8],pc)+dist(lm[12],pc)+dist(lm[16],pc)+dist(lm[20],pc))/4;

    // open: è‡³å°‘4æŒ‡ä¼¸ç›´
    if (count >= 4) return {name:"å¼ å¼€ğŸ–ï¸", target:0};
    // fist: ä¼¸ç›´<=1 ä¸”æŒ‡å°–é è¿‘æŒå¿ƒ
    if (count <= 1 && closeScore < 0.18) return {name:"æ¡æ‹³âœŠ", target:1};

    // å…¶å®ƒä¸­é—´æ€ï¼šä¿æŒå½“å‰ç›®æ ‡ï¼ˆä¸è·³å˜ï¼‰
    return {name:"è¿‡æ¸¡â€¦", target:null};
  }

  resetBtn.onclick = () => {
    handX = 0.52; handY = 0.45;
    modeTarget = 0;
    mode = 0;
  };

  // ===== Boids update =====
  // é‚»åŸŸåŠå¾„ï¼ˆè¶Šå¤§è¶Šåƒé¸Ÿç¾¤ï¼‰
  const R = 0.06;
  const R2 = R*R;

  function boidsStep(dt){
    // å¹³æ»‘æ¨¡å¼ï¼šè®©èšæ‹¢/æ•£å¼€â€œè½¯â€èµ·æ¥
    mode = lerp(mode, modeTarget, 0.08);

    // æ¨¡å¼é©±åŠ¨å‚æ•°ï¼ˆ0æ•£å¼€å›æ ‘é‡Œ / 1èšæ‹¢åˆ°æ‰‹ï¼‰
    const cohesionK  = lerp(0.18, 0.42, mode);
    const alignK     = lerp(0.12, 0.35, mode);
    const separateK  = lerp(0.55, 0.95, 1-mode); // æ•£å¼€æ—¶åˆ†ç¦»æ›´å¼º
    const maxSpeed   = lerp(0.22, 0.35, mode);
    const wanderK    = lerp(0.10, 0.04, mode);

    for (let i=0;i<boids.length;i++){
      const b = boids[i];

      // boids rules accumulators
      let cx=0, cy=0, ax=0, ay=0, sx=0, sy=0, cnt=0;

      // ç®€æ˜“ O(N^2) é‚»åŸŸæœç´¢ï¼ˆN=1400 ä»å¯è·‘ï¼›æ‰‹æœºå¡å°±é™ Nï¼‰
      for (let j=0;j<boids.length;j+=3){ // æŠ½æ ·é‚»å±…ï¼Œææ€§èƒ½ï¼ˆå…³é”®ï¼šæ›´åƒâ€œç¾¤â€ä¸”ä¸å¡ï¼‰
        if (i===j) continue;
        const o = boids[j];
        const dx = o.x - b.x;
        const dy = o.y - b.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < R2){
          cnt++;
          cx += o.x; cy += o.y;       // cohesion
          ax += o.vx; ay += o.vy;     // alignment
          // separationï¼ˆè¿‘è·ç¦»æ›´å¼ºï¼‰
          const inv = 1/(d2 + 1e-4);
          sx -= dx*inv; sy -= dy*inv;
        }
      }

      let fx=0, fy=0;

      if (cnt>0){
        cx/=cnt; cy/=cnt; ax/=cnt; ay/=cnt;
        fx += (cx - b.x) * cohesionK;
        fy += (cy - b.y) * cohesionK;

        fx += (ax - b.vx) * alignK;
        fy += (ay - b.vy) * alignK;

        fx += sx * separateK;
        fy += sy * separateK;
      }

      // â€œæ ‘å½¢åœºâ€ï¼šæ•£å¼€æ—¶å›åˆ°è‡ªå·±çš„ anchorï¼›èšæ‹¢æ—¶å‘æ‰‹çš„ä¸­å¿ƒ
      const a = anchors[b.aIdx];
      const targetX = lerp(a.u, handX, mode);
      const targetY = lerp(a.v, handY, mode);

      // å¸å¼•æ˜¯â€œè½¯çš„â€ï¼Œä¸æ˜¯ç¡¬æ‹‰
      fx += (targetX - b.x) * lerp(0.30, 0.75, mode);
      fy += (targetY - b.y) * lerp(0.30, 0.75, mode);

      // å°‘é‡â€œæ¼‚ç§»å™ªå£°â€ï¼Œæ›´åƒé¸Ÿç¾¤/ç¯ä¸²åœ¨æµåŠ¨
      const t = performance.now()*0.001;
      fx += (Math.sin(t*1.7 + b.tw*10) * wanderK);
      fy += (Math.cos(t*1.3 + b.tw*10) * wanderK);

      // integrate
      b.vx = (b.vx + fx*dt) * 0.92;
      b.vy = (b.vy + fy*dt) * 0.92;

      // speed limit
      const sp = Math.hypot(b.vx,b.vy);
      if (sp > maxSpeed){
        b.vx = b.vx/sp * maxSpeed;
        b.vy = b.vy/sp * maxSpeed;
      }

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // soft bounds
      b.x = clamp(b.x, 0.02, 0.98);
      b.y = clamp(b.y, 0.02, 0.98);
    }
  }

  // ===== Render (more like your picture: colorful glowing particles) =====
  function draw(){
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    if (showCamera && video.readyState >= 2){
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.translate(w,0);
      ctx.scale(-1,1);
      ctx.drawImage(video, 0,0,w,h);
      ctx.restore();
    }

    // background vignette
    ctx.save();
    const g = ctx.createRadialGradient(w*0.5, h*0.35, 10, w*0.5, h*0.35, w*0.9);
    g.addColorStop(0, "rgba(255,255,255,0.02)");
    g.addColorStop(1, "rgba(0,0,0,0.35)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    // top diamond (åƒä½ å›¾é‡Œçš„è±å½¢é¡¶ç¯)
    const topX = TREE.cx*w;
    const topY = TREE.top*h - 10;
    ctx.save();
    ctx.translate(topX, topY);
    ctx.rotate(Math.PI/4);
    ctx.fillStyle = "rgba(140,220,255,0.95)";
    ctx.shadowColor = "rgba(140,220,255,0.55)";
    ctx.shadowBlur = 18;
    ctx.fillRect(-14,-14,28,28);
    ctx.restore();

    // particles
    ctx.save();
    ctx.globalCompositeOperation = "lighter"; // æ›´åƒéœ“è™¹/ç¯ç å åŠ 
    for (const b of boids){
      // åœ¨å›æ ‘é‡Œæ—¶ï¼Œå°½é‡é™åˆ¶åœ¨æ ‘åŒºåŸŸé™„è¿‘ï¼ˆæ›´åƒâ€œæ ‘å½¢â€ï¼‰
      if (mode < 0.65 && !insideTree(b.x, b.y)) continue;

      const x = b.x*w;
      const y = b.y*h;

      const tw = 0.55 + 0.45*Math.sin(performance.now()*0.007 + b.tw*8);
      const r = b.baseR * (0.85 + 0.55*tw);

      // å½©è‰²ç¯ç ï¼ˆä½ å›¾é‡Œæ˜¯å¾ˆå¤šé¢œè‰²æ··åœ¨ä¸€èµ·ï¼‰
      ctx.fillStyle = hsvToRgba(b.hue, 0.85, 1.0, 0.55 + 0.35*tw);
      ctx.shadowColor = hsvToRgba(b.hue, 0.95, 1.0, 0.35);
      ctx.shadowBlur = 10;

      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // ui debug dot
    if (haveHand){
      ctx.save();
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(34,197,94,0.95)";
      ctx.beginPath();
      ctx.arc(handX*w, handY*h, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // ===== Animation loop =====
  let lastT = performance.now();
  function loop(t){
    const dt = Math.min(0.033, (t-lastT)/1000);
    lastT = t;
    boidsStep(dt*1.0);
    draw();
    requestAnimationFrame(loop);
  }

  // ===== MediaPipe Hands (manual feed) =====
  let hands = null;
  let detecting = false;

  function setupHands(){
    hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.35,
      minTrackingConfidence: 0.35
    });

    hands.onResults((res) => {
      lastResultsAt = performance.now();
      setLastRes("æ”¶åˆ°", "ok");

      if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0){
        haveHand = false;
        handEl.textContent = "æœªæ£€æµ‹";
        // æ²¡æ‰‹æ—¶æ…¢æ…¢å›æ ‘é‡Œ
        modeTarget = 0;
        pinchEl.textContent = "â€”";
        return;
      }

      haveHand = true;
      handEl.textContent = "å·²æ£€æµ‹";

      const lm = res.multiHandLandmarks[0];

      // ä»¥é£ŸæŒ‡æŒ‡å°–ä¸ºç§»åŠ¨ä¸­å¿ƒï¼ˆé•œåƒåæ›´ç¬¦åˆç›´è§‰ï¼‰
      const indexTip = lm[8];
      const hx = 1 - indexTip.x;
      const hy = indexTip.y;
      handX = lerp(handX, hx, 0.25);
      handY = lerp(handY, hy, 0.25);

      // æ‰‹åŠ¿ï¼šå¼ å¼€/æ¡æ‹³ æ§åˆ¶èšæ‹¢/æ•£å¼€
      const g = gestureFromLandmarks(lm);
      if (g.target !== null) modeTarget = g.target;

      pinchEl.textContent = g.name;
    });
  }

  async function startCamera(){
    setStatus("ç”³è¯·æ‘„åƒå¤´æƒé™â€¦", "warn");
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode:"user", width:{ideal:640}, height:{ideal:480} }, // æ‰‹æœºæ›´ç¨³
      audio:false
    });
    video.srcObject = stream;
    await video.play();
    setStatus("æ‘„åƒå¤´å·²å¼€å¯ï¼Œç­‰å¾…è§†é¢‘å¸§â€¦", "warn");
  }

  async function feedLoop(){
    if (!detecting) return;

    if (video.readyState >= 2){
      videoFrames++;
      frameEl.textContent = String(videoFrames);

      if (videoFrames === 1) setStatus("å·²æ”¶åˆ°è§†é¢‘å¸§ï¼Œå¼€å§‹æ£€æµ‹â€¦", "ok");

      try{
        await hands.send({ image: video });
      }catch(e){
        setStatus("æ£€æµ‹è°ƒç”¨å¤±è´¥ï¼ˆè„šæœ¬åŠ è½½/ç½‘ç»œé—®é¢˜ï¼‰", "bad");
        console.error(e);
      }
    }

    const now = performance.now();
    if (videoFrames > 0){
      if (now - lastResultsAt > 1200) setLastRes("æ£€æµ‹ä¸­â€¦", "warn");
    }

    setTimeout(feedLoop, 50);
  }

  startBtn.onclick = async () => {
    try{
      startBtn.disabled = true;
      startBtn.textContent = "å¯åŠ¨ä¸­â€¦";

      await startCamera();
      setupHands();

      detecting = true;
      setStatus("è¿è¡Œä¸­ï¼ˆå¼ å¼€ğŸ–ï¸æ•£å¼€ / æ¡æ‹³âœŠèšæ‹¢ï¼‰", "ok");
      feedLoop();

      startBtn.textContent = "æ‘„åƒå¤´å·²å¼€å¯ âœ…";
    }catch(e){
      console.error(e);
      setStatus("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼ˆæ£€æŸ¥ HTTPS/æƒé™/æµè§ˆå™¨ï¼‰", "bad");
      startBtn.disabled = false;
      startBtn.textContent = "å¼€å¯æ‘„åƒå¤´";
      alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼šè¯·åœ¨ HTTPS æ‰“å¼€å¹¶å…è®¸æƒé™ï¼›iPhone å»ºè®® Safariï¼Œåˆ«ç”¨å¾®ä¿¡å†…ç½®æµè§ˆå™¨ã€‚");
    }
  };

  // init
  setStatus("æœªå¯åŠ¨", "warn");
  setLastRes("â€”", "warn");
  requestAnimationFrame(loop);

  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    setStatus("æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ API", "bad");
  }
})();

</script>
</body>
</html>
